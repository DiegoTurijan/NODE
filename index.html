<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SimpleMind Pro - Import/Export</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --node-bg: #2c2c2e;
            --node-text: #ffffff;
            --node-border: #3a3a3c;
            --node-shadow: rgba(0, 0, 0, 0.3);
            --connector-color: #48484a;
            --selected-color: #0a84ff;
            --highlight-color: #30d158;
            --toolbar-bg: #2c2c2e;
            --toolbar-btn: #3a3a3c;
            --toolbar-btn-active: #0a84ff;
            --text-primary: #ffffff;
            --text-secondary: #aeaeb2;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            overflow: hidden;
            touch-action: manipulation;
            height: 100vh;
        }
        
        #app {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        #canvas-container {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }
        
        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            cursor: grab;
            transform-origin: 0 0;
            will-change: transform;
        }
        
        .node {
            position: absolute;
            min-width: 160px;
            min-height: 60px; /* Minimum height for padding and border */
            background-color: var(--node-bg);
            border-radius: 12px;
            box-shadow: 0 4px 16px var(--node-shadow);
            padding: 16px;
            font-size: 18px;
            cursor: pointer;
            border: 2px solid var(--node-border);
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
            word-break: break-word;
            user-select: none;
            touch-action: none;
            color: var(--node-text);
            display: flex; /* For textarea alignment */
            align-items: center; /* For textarea alignment */
            justify-content: center; /* For textarea alignment */
        }
        
        .node.selected {
            border-color: var(--selected-color);
            box-shadow: 0 6px 20px rgba(10, 132, 255, 0.2);
        }
        
        .node.dragging {
            opacity: 0.8;
            z-index: 1000;
            transition: none;
        }
        
        .node.highlight {
            border-color: var(--highlight-color);
            background-color: rgba(48, 209, 88, 0.1);
        }
        
        .node-input {
            width: 100%;
            /* height: 100%; Let JS control height */
            border: none;
            outline: none;
            font-size: 18px;
            background: transparent;
            resize: none;
            overflow: hidden;
            font-family: inherit;
            pointer-events: none;
            color: var(--node-text);
            text-align: center; /* Center text in textarea */
        }
        
        .node-input.editing {
            pointer-events: auto;
            user-select: auto;
        }
        
        .node-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.7;
        }
        
        #toolbar {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background-color: var(--toolbar-bg);
            border-radius: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            padding: 12px;
            z-index: 100;
            gap: 10px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .tool-btn {
            width: 54px;
            height: 54px;
            border-radius: 50%;
            background-color: var(--toolbar-btn);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
        }
        
        .tool-btn:active {
            transform: scale(0.95);
        }
        
        .tool-btn.primary {
            background-color: var(--selected-color);
        }
        
        .tool-btn.toggle {
            background-color: var(--toolbar-btn);
        }
        
        .tool-btn.toggle.active {
            background-color: var(--selected-color);
        }
        
        .connector {
            position: absolute;
            pointer-events: none;
            stroke: var(--connector-color);
            stroke-width: 3;
            fill: none;
        }
        
        #zoom-controls {
            position: fixed;
            right: 20px;
            bottom: 120px; /* Adjusted to avoid overlap with toolbar */
            display: flex;
            flex-direction: column;
            z-index: 100;
            gap: 10px;
        }
        
        .zoom-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--toolbar-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            color: var(--text-primary);
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            touch-action: manipulation;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        #title-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 64px;
            background-color: rgba(44, 44, 46, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        #menu-btn { /* Placeholder for future menu */
            position: absolute;
            left: 20px;
            font-size: 28px;
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
        }
        
        .color-palette {
            display: none;
            position: absolute;
            bottom: 100px; /* Adjusted based on toolbar height */
            left: 50%;
            transform: translateX(-50%);
            background: var(--toolbar-bg);
            border-radius: 20px;
            padding: 14px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            z-index: 101;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: inline-block;
            margin: 8px;
            border: 2px solid transparent;
            transition: transform 0.2s;
            cursor: pointer;
        }
        
        .color-option:hover {
            transform: scale(1.1);
        }
        
        .color-option.selected {
            border-color: var(--text-primary);
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            .node {
                min-width: 140px;
                /* min-height: 50px; */ /* Let content define height */
                font-size: 16px;
                padding: 12px;
            }

            .node-input {
                font-size: 16px;
            }

            .tool-btn {
                width: 48px;
                height: 48px;
                font-size: 22px;
            }

            #toolbar {
                bottom: 20px;
                padding: 10px;
                gap: 8px;
            }
            #zoom-controls {
                bottom: 100px; /* Further adjust for smaller toolbar */
            }
            .color-palette {
                bottom: 90px; /* Adjust for smaller toolbar */
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="title-bar">
            <button id="menu-btn" title="Menu">â‰¡</button>
            <div id="title">SimpleMind Pro</div>
        </div>
        <div id="canvas-container">
            <div id="canvas"></div>
        </div>
        
        <div id="zoom-controls">
            <button class="zoom-btn" id="zoom-in" title="Acercar">+</button>
            <button class="zoom-btn" id="zoom-out" title="Alejar">-</button>
            <button class="zoom-btn" id="zoom-reset" title="Restablecer Zoom">â†»</button>
        </div>
        
        <div id="toolbar">
            <button class="tool-btn" id="add-child" title="AÃ±adir Hijo">+</button>
            <button class="tool-btn" id="delete-btn" title="Eliminar Nodo">ðŸ—‘</button>
            <button class="tool-btn" id="color-btn" title="Color Nodo">ðŸŽ¨</button>
            <button class="tool-btn toggle" id="auto-arrange" title="Auto Organizar">â‡†</button>
            <button class="tool-btn primary" id="center-btn" title="Centrar Vista">â—Ž</button>
            <button class="tool-btn" id="import-btn" title="Importar Mapa">ðŸ“¥</button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;">
            <button class="tool-btn" id="export-btn" title="Exportar Mapa">ðŸ“¤</button>
        </div>
        
        <div class="color-palette" id="color-palette">
            <div class="color-option" style="background-color: #0a84ff;" data-color="#0a84ff"></div>
            <div class="color-option" style="background-color: #30d158;" data-color="#30d158"></div>
            <div class="color-option" style="background-color: #ff453a;" data-color="#ff453a"></div>
            <div class="color-option" style="background-color: #ffd60a;" data-color="#ffd60a"></div>
            <div class="color-option" style="background-color: #bf5af2;" data-color="#bf5af2"></div>
            <div class="color-option" style="background-color: #64d2ff;" data-color="#64d2ff"></div>
            <div class="color-option" style="background-color: var(--node-bg);" data-color="var(--node-bg)"></div> </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // App state
            const state = {
                nodes: [],
                connections: [],
                selectedNode: null,
                nextId: 1,
                scale: 1,
                minScale: 0.2,
                maxScale: 3,
                offsetX: 0,
                offsetY: 0,
                isDragging: false,
                isPanning: false,
                dragNode: null,
                dragStartPos: { x: 0, y: 0 },
                touchStart: { x: 0, y: 0 },
                lastClickTime: 0,
                potentialParent: null,
                initialPinchDistance: null,
                initialScale: 1,
                autoArrange: false,
                horizontalLayout: window.innerWidth > 768 
            };
            
            // DOM elements
            const canvasContainer = document.getElementById('canvas-container');
            const canvas = document.getElementById('canvas');
            const addChildBtn = document.getElementById('add-child');
            const deleteBtn = document.getElementById('delete-btn');
            const colorBtn = document.getElementById('color-btn');
            const autoArrangeBtn = document.getElementById('auto-arrange');
            const centerBtn = document.getElementById('center-btn');
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');
            const zoomResetBtn = document.getElementById('zoom-reset');
            const colorPalette = document.getElementById('color-palette');
            const importBtn = document.getElementById('import-btn');
            const importFileInput = document.getElementById('import-file-input');
            const exportBtn = document.getElementById('export-btn');
            
            // Check device type and set initial layout
            function checkDeviceType() {
                const isDesktop = window.innerWidth > 768;
                if (state.horizontalLayout !== isDesktop) {
                    state.horizontalLayout = isDesktop;
                    if (state.autoArrange) arrangeNodes();
                    else updateConnections();
                }
            }
            
            window.addEventListener('resize', checkDeviceType);
            
            // Initialize with a central node
            const initialNode = createNode('Idea Central', window.innerWidth / 2, window.innerHeight / 2);
            // Center the initial node properly after creation
            initialNode.x -= initialNode.width / 2;
            initialNode.y -= initialNode.height / 2;
            initialNode.element.style.left = `${initialNode.x}px`;
            initialNode.element.style.top = `${initialNode.y}px`;
            selectNode(initialNode);
            
            // Event listeners
            addChildBtn.addEventListener('click', addChildNode);
            deleteBtn.addEventListener('click', deleteSelectedNode);
            colorBtn.addEventListener('click', toggleColorPalette);
            autoArrangeBtn.addEventListener('click', toggleAutoArrange);
            centerBtn.addEventListener('click', centerViewOnSelectedOrRoot);
            zoomInBtn.addEventListener('click', () => zoom(1.2));
            zoomOutBtn.addEventListener('click', () => zoom(0.8));
            zoomResetBtn.addEventListener('click', resetZoom);
            exportBtn.addEventListener('click', exportMapData);
            importBtn.addEventListener('click', () => importFileInput.click());
            importFileInput.addEventListener('change', handleFileImport);
            
            setupCanvasEvents();
            
            document.querySelectorAll('.color-option').forEach(option => {
                option.addEventListener('click', function() {
                    if (state.selectedNode) {
                        const colorValue = this.getAttribute('data-color');
                        // Resolve CSS variable if present
                        const actualColor = colorValue.startsWith('var(') ? 
                                            getComputedStyle(document.documentElement).getPropertyValue(colorValue.slice(4, -1)).trim() : 
                                            colorValue;
                        state.selectedNode.element.style.backgroundColor = actualColor;
                        state.selectedNode.color = actualColor; // Store the resolved color
                        colorPalette.style.display = 'none';
                    }
                });
            });
            
            // --- Main Functions ---
            function createNode(text, x, y, existingId = null, nodeColor = null, nodeWidth = null, nodeHeight = null) {
                const nodeId = existingId !== null ? existingId : state.nextId++;
                
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.dataset.id = nodeId;
                
                const textarea = document.createElement('textarea');
                textarea.className = 'node-input';
                textarea.placeholder = 'Escribe aquÃ­';
                textarea.value = text;
                nodeElement.appendChild(textarea);

                // Apply explicit width if provided, otherwise CSS min-width will apply
                if (nodeWidth !== null) {
                    nodeElement.style.width = `${nodeWidth}px`;
                }
                // Apply explicit height if provided, otherwise content + padding will determine it
                if (nodeHeight !== null) {
                     nodeElement.style.height = `${nodeHeight}px`;
                }
                
                if (nodeColor) {
                    nodeElement.style.backgroundColor = nodeColor;
                } else {
                     // Ensure default background is applied if no color is specified
                    nodeElement.style.backgroundColor = 'var(--node-bg)';
                }
                
                // Position initially, will be refined after adding to DOM and measuring
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;

                canvas.appendChild(nodeElement);
                
                // Adjust textarea height based on content AFTER it's in the DOM
                const finalHeight = adjustTextareaHeight(textarea);
                // The nodeElement's height will be textarea's scrollHeight + padding (due to CSS box-sizing and padding)
                // If nodeHeight was provided, it might override this. For consistency, let's use offsetHeight.
                
                const node = {
                    id: nodeId,
                    element: nodeElement,
                    x, y,
                    width: nodeElement.offsetWidth, 
                    height: nodeElement.offsetHeight,
                    parentId: null, 
                    text: text,
                    originalParentId: null, 
                    children: [],
                    depth: 0, 
                    color: nodeColor || getComputedStyle(nodeElement).backgroundColor // Store actual initial color
                };

                state.nodes.push(node);
                
                nodeElement.addEventListener('mousedown', handleNodeMouseDown);
                nodeElement.addEventListener('touchstart', handleNodeTouchStart, { passive: false });
                
                textarea.addEventListener('input', function() {
                    adjustTextareaHeight(this);
                    node.text = this.value;
                    node.width = nodeElement.offsetWidth; // Update width if it can change
                    node.height = nodeElement.offsetHeight; // Update height based on content
                    updateConnections();
                    if (state.autoArrange) arrangeNodes();
                });
                
                textarea.addEventListener('blur', function() {
                    this.classList.remove('editing');
                    if (this.value.trim() === '') {
                        this.value = 'Nuevo nodo';
                        node.text = 'Nuevo nodo';
                        adjustTextareaHeight(this);
                        node.height = nodeElement.offsetHeight;
                    }
                });
                 // After text is set and textarea adjusted, update node dimensions
                node.width = nodeElement.offsetWidth;
                node.height = nodeElement.offsetHeight;

                return node;
            }

            function adjustTextareaHeight(textarea) {
                textarea.style.height = 'auto'; // Temporarily shrink to get accurate scrollHeight
                let scrollHeight = textarea.scrollHeight;
                const minHeight = 20; // Minimum content height for textarea itself
                textarea.style.height = Math.max(scrollHeight, minHeight) + 'px';
                return Math.max(scrollHeight, minHeight); // Return the content height
            }

            function createConnection(fromId, toId) {
                state.connections = state.connections.filter(conn => conn.toId !== toId || conn.fromId !== fromId); // Avoid duplicates
                const connection = { fromId, toId };
                state.connections.push(connection);
                // updateConnections(); // Caller should handle batch updates
                return connection;
            }

            function updateConnections() {
                document.querySelectorAll('.connector').forEach(el => el.remove());
                state.connections.forEach(conn => {
                    const fromNode = state.nodes.find(n => n.id === conn.fromId);
                    const toNode = state.nodes.find(n => n.id === conn.toId);
                    if (fromNode && toNode) {
                        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                        svg.classList.add('connector');
                        // SVG positioning needs to be relative to the canvas, not individual nodes
                        svg.style.position = 'absolute';
                        svg.style.top = '0';
                        svg.style.left = '0';
                        svg.style.width = '100%'; // Cover entire canvas
                        svg.style.height = '100%';
                        svg.style.pointerEvents = 'none';
                        svg.style.overflow = 'visible'; // Important for paths going outside initial bounds

                        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        
                        let fromX, fromY, toX, toY;

                        if (state.horizontalLayout) {
                            fromX = fromNode.x + fromNode.width;
                            fromY = fromNode.y + fromNode.height / 2;
                            toX = toNode.x;
                            toY = toNode.y + toNode.height / 2;
                            const controlX1 = fromX + Math.max(50, (toX - fromX) * 0.3);
                            const controlX2 = toX - Math.max(50, (toX - fromX) * 0.3);
                            path.setAttribute('d', `M ${fromX} ${fromY} C ${controlX1} ${fromY}, ${controlX2} ${toY}, ${toX} ${toY}`);
                        } else {
                            fromX = fromNode.x + fromNode.width / 2;
                            fromY = fromNode.y + fromNode.height;
                            toX = toNode.x + toNode.width / 2;
                            toY = toNode.y;
                            const controlY1 = fromY + Math.max(50, (toY - fromY) * 0.3);
                            const controlY2 = toY - Math.max(50, (toY - fromY) * 0.3);
                            path.setAttribute('d', `M ${fromX} ${fromY} C ${fromX} ${controlY1}, ${toX} ${controlY2}, ${toX} ${toY}`);
                        }
                        
                        path.setAttribute('stroke', 'var(--connector-color)');
                        path.setAttribute('stroke-width', '3');
                        path.setAttribute('fill', 'none');
                        svg.appendChild(path);
                        canvas.appendChild(svg); // Append to main canvas div
                    }
                });
            }
            
            function selectNode(node) {
                if (state.selectedNode) {
                    state.selectedNode.element.classList.remove('selected');
                    state.selectedNode.element.querySelector('.node-input').classList.remove('editing');
                }
                state.selectedNode = node;
                if (node) {
                    node.element.classList.add('selected');
                }
                colorPalette.style.display = 'none';
            }
            
            function editNode(node) {
                if (!node) return;
                selectNode(node);
                const textarea = node.element.querySelector('.node-input');
                textarea.classList.add('editing');
                textarea.focus();
                textarea.setSelectionRange(0, textarea.value.length);
            }
            
            function addChildNode() {
                if (!state.selectedNode) {
                    if (state.nodes.length === 0) { // If no nodes, create a root node first
                         const newNode = createNode('Nueva Idea', window.innerWidth / 2, window.innerHeight / 2);
                         newNode.x -= newNode.width/2; // Center it
                         newNode.y -= newNode.height/2;
                         newNode.element.style.left = `${newNode.x}px`;
                         newNode.element.style.top = `${newNode.y}px`;
                         selectNode(newNode);
                         editNode(newNode);
                         return;
                    } else {
                        alert("Por favor, selecciona un nodo padre primero."); // Or use a custom message box
                        return;
                    }
                }

                const parent = state.selectedNode;
                let x, y;
                const spacing = 80; // Increased spacing

                if (state.horizontalLayout) {
                    x = parent.x + parent.width + spacing;
                    y = parent.y + parent.height / 2; // Align centers vertically initially
                } else {
                    x = parent.x + parent.width / 2; // Align centers horizontally initially
                    y = parent.y + parent.height + spacing;
                }
                
                const newNode = createNode('Nuevo Hijo', x, y);
                // Adjust position based on new node's size
                if (state.horizontalLayout) {
                     y -= newNode.height / 2;
                } else {
                     x -= newNode.width / 2;
                }
                newNode.x = x;
                newNode.y = y;
                newNode.element.style.left = `${x}px`;
                newNode.element.style.top = `${y}px`;
                
                newNode.parentId = parent.id;
                newNode.originalParentId = parent.id;
                newNode.depth = (parent.depth || 0) + 1;
                parent.children.push(newNode);
                createConnection(parent.id, newNode.id);
                
                selectNode(newNode);
                setTimeout(() => editNode(newNode), 50);
                
                if (state.autoArrange) {
                    arrangeNodes();
                } else {
                    updateConnections();
                }
            }
            
            function deleteSelectedNode() {
                if (!state.selectedNode) return;
            
                const nodeToDelete = state.selectedNode;
                const childrenToDelete = getAllDescendants(nodeToDelete.id);
                const idsToDelete = [nodeToDelete.id, ...childrenToDelete.map(n => n.id)];
            
                // Remove nodes from DOM and state
                idsToDelete.forEach(id => {
                    const node = state.nodes.find(n => n.id === id);
                    if (node) node.element.remove();
                });
                state.nodes = state.nodes.filter(n => !idsToDelete.includes(n.id));
            
                // Remove connections involving deleted nodes
                state.connections = state.connections.filter(conn => 
                    !idsToDelete.includes(conn.fromId) && !idsToDelete.includes(conn.toId)
                );
            
                // Remove from parent's children array
                if (nodeToDelete.parentId) {
                    const parent = state.nodes.find(n => n.id === nodeToDelete.parentId);
                    if (parent) {
                        parent.children = parent.children.filter(child => child.id !== nodeToDelete.id);
                    }
                }
            
                state.selectedNode = null;
                if (state.autoArrange) {
                    arrangeNodes();
                } else {
                    updateConnections();
                }
            }

            function getAllDescendants(parentId) {
                let descendants = [];
                const directChildren = state.nodes.filter(node => node.parentId === parentId);
                for (const child of directChildren) {
                    descendants.push(child);
                    descendants = descendants.concat(getAllDescendants(child.id));
                }
                return descendants;
            }
            
            function toggleAutoArrange() {
                state.autoArrange = !state.autoArrange;
                autoArrangeBtn.classList.toggle('active', state.autoArrange);
                if (state.autoArrange) {
                    arrangeNodes();
                }
            }
            
            function arrangeNodes() {
                if (state.nodes.length === 0) return;
                const rootNodes = state.nodes.filter(node => !node.parentId || !state.nodes.find(p => p.id === node.parentId)); // Handle orphaned nodes as roots
                
                if (rootNodes.length === 0 && state.nodes.length > 0) { // Fallback if no clear root (e.g. after bad import)
                    rootNodes.push(state.nodes[0]);
                }

                if (rootNodes.length === 0) return;

                // Recalculate depths first
                const visited = new Set();
                function calculateDepthRecursive(node, d) {
                    if (!node || visited.has(node.id)) return;
                    visited.add(node.id);
                    node.depth = d;
                    node.children = state.nodes.filter(n => n.parentId === node.id); // Rebuild children array
                    node.children.forEach(child => calculateDepthRecursive(child, d + 1));
                }
                rootNodes.forEach(root => calculateDepthRecursive(root, 0));


                // Simple tree layout (can be improved)
                const xSpacing = 250; // Increased spacing
                const ySpacing = 120; // Increased spacing
                let currentY = 50; // Initial Y offset for multiple root nodes if any
                
                rootNodes.forEach(rootNode => {
                    const treeNodes = getTreeNodes(rootNode);
                    const levels = {};
                    treeNodes.forEach(node => {
                        if (!levels[node.depth]) levels[node.depth] = [];
                        levels[node.depth].push(node);
                    });

                    if (state.horizontalLayout) {
                        let currentRootY = currentY;
                        Object.keys(levels).sort((a,b) => a-b).forEach(level => {
                            const nodesAtLevel = levels[level];
                            const levelWidth = nodesAtLevel.reduce((sum, n) => sum + n.width, 0) + (nodesAtLevel.length -1) * (ySpacing/2);
                            let nodeX = rootNode.x + (parseInt(level) * xSpacing);
                            let nodeYOffset = currentRootY - levelWidth / 2;

                            nodesAtLevel.forEach(node => {
                                node.x = nodeX;
                                node.y = nodeYOffset + node.height/2; // Center vertically within its slot
                                node.element.style.left = `${node.x}px`;
                                node.element.style.top = `${node.y}px`;
                                nodeYOffset += node.height + (ySpacing/2);
                            });
                        });
                        // Estimate total height of this tree for next root node placement
                        const lastLevel = levels[Math.max(...Object.keys(levels).map(Number))];
                        if (lastLevel && lastLevel.length > 0) {
                           currentY = Math.max(currentY, lastLevel[lastLevel.length-1].y + lastLevel[lastLevel.length-1].height + ySpacing);
                        }


                    } else { // Vertical layout
                        let currentRootX = rootNode.x; // Use root's current X as a base
                        Object.keys(levels).sort((a,b) => a-b).forEach(level => {
                            const nodesAtLevel = levels[level];
                            const levelHeight = nodesAtLevel.reduce((sum, n) => sum + n.height, 0) + (nodesAtLevel.length -1) * (xSpacing/2);
                            let nodeY = rootNode.y + (parseInt(level) * ySpacing);
                            let nodeXOffset = currentRootX - levelHeight / 2;

                            nodesAtLevel.forEach(node => {
                                node.y = nodeY;
                                node.x = nodeXOffset + node.width/2; // Center horizontally
                                node.element.style.left = `${node.x}px`;
                                node.element.style.top = `${node.y}px`;
                                nodeXOffset += node.width + (xSpacing/2);
                            });
                        });
                         const lastLevel = levels[Math.max(...Object.keys(levels).map(Number))];
                         if (lastLevel && lastLevel.length > 0) {
                            // This part needs adjustment for multiple roots in vertical
                         }
                    }
                });
                updateConnections();
            }

            function getTreeNodes(rootNode) {
                const tree = [];
                const queue = [rootNode];
                const visited = new Set();
                visited.add(rootNode.id);
                tree.push(rootNode);

                while (queue.length > 0) {
                    const current = queue.shift();
                    const children = state.nodes.filter(n => n.parentId === current.id && !visited.has(n.id));
                    children.forEach(child => {
                        visited.add(child.id);
                        tree.push(child);
                        queue.push(child);
                    });
                }
                return tree;
            }


            function toggleColorPalette() {
                colorPalette.style.display = (colorPalette.style.display === 'block') ? 'none' : 'block';
            }
            
            function centerViewOnSelectedOrRoot() {
                let targetNode = state.selectedNode;
                if (!targetNode && state.nodes.length > 0) {
                    targetNode = state.nodes.find(n => !n.parentId) || state.nodes[0]; // Prefer root, fallback to first
                }

                if (targetNode) {
                    const targetX = targetNode.x + targetNode.width / 2;
                    const targetY = targetNode.y + targetNode.height / 2;
                    
                    state.offsetX = (window.innerWidth / 2) - (targetX * state.scale);
                    state.offsetY = (window.innerHeight / 2) - (targetY * state.scale);
                    updateCanvasTransform();
                }
            }
            
            function zoom(factor, clientX = window.innerWidth / 2, clientY = window.innerHeight / 2) {
                const prevScale = state.scale;
                state.scale = Math.max(state.minScale, Math.min(state.maxScale, state.scale * factor));
                
                // Zoom towards the mouse pointer or center of the screen
                state.offsetX = clientX - (clientX - state.offsetX) * (state.scale / prevScale);
                state.offsetY = clientY - (clientY - state.offsetY) * (state.scale / prevScale);
                
                updateCanvasTransform();
            }
            
            function resetZoom() {
                state.scale = 1;
                state.offsetX = 0;
                state.offsetY = 0;
                updateCanvasTransform();
                centerViewOnSelectedOrRoot(); // Recenter after reset
            }
            
            function updateCanvasTransform() {
                canvas.style.transform = `translate(${state.offsetX}px, ${state.offsetY}px) scale(${state.scale})`;
                updateConnections(); // Connections are drawn in absolute canvas space, so they need update on pan/zoom
            }
            
            // --- Event Handlers (Panning, Dragging, Touch) ---
            function setupCanvasEvents() {
                canvasContainer.addEventListener('mousedown', startPan);
                canvasContainer.addEventListener('touchstart', startPan, { passive: false });
                document.addEventListener('mousemove', handlePanOrDrag);
                document.addEventListener('touchmove', handlePanOrDrag, { passive: false });
                document.addEventListener('mouseup', endPanOrDrag);
                document.addEventListener('touchend', endPanOrDrag);
                canvasContainer.addEventListener('wheel', handleWheelZoom, { passive: false });

                canvasContainer.addEventListener('click', (e) => {
                    if (e.target === canvasContainer || e.target === canvas) { // Click on empty space
                        if (state.selectedNode) {
                           selectNode(null); // Deselect
                        }
                    }
                });
            }

            function handleWheelZoom(e) {
                e.preventDefault();
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                zoom(zoomFactor, e.clientX, e.clientY);
            }

            function startPan(e) {
                // Only pan if not clicking on a node
                let targetElement = e.target;
                let isNodeTarget = false;
                while(targetElement && targetElement !== canvasContainer) {
                    if (targetElement.classList && targetElement.classList.contains('node')) {
                        isNodeTarget = true;
                        break;
                    }
                    targetElement = targetElement.parentNode;
                }

                if (!isNodeTarget && (e.target === canvasContainer || e.target === canvas)) {
                    state.isPanning = true;
                    const clientX = e.clientX || e.touches[0].clientX;
                    const clientY = e.clientY || e.touches[0].clientY;
                    state.touchStart = { x: clientX - state.offsetX, y: clientY - state.offsetY };
                    canvas.style.cursor = 'grabbing';
                    if (e.preventDefault && e.touches) e.preventDefault(); // Prevent page scroll on touch
                }
            }

            function handleNodeMouseDown(e) {
                e.stopPropagation(); // Prevent canvas pan when clicking node
                const nodeId = parseInt(this.dataset.id);
                const node = state.nodes.find(n => n.id === nodeId);
                if (!node) return;

                const currentTime = new Date().getTime();
                if ((currentTime - state.lastClickTime) < 300) { // Double click/tap
                    editNode(node);
                    state.lastClickTime = 0; // Reset for next double click
                    return;
                }
                state.lastClickTime = currentTime;
                
                selectNode(node);
                if (state.autoArrange) return; // No dragging if auto-arrange is on

                state.isDragging = true;
                state.dragNode = node;
                const clientX = e.clientX;
                const clientY = e.clientY;
                state.dragStartPos = { 
                    x: node.x, y: node.y, 
                    clientX: clientX, clientY: clientY 
                };
                node.element.classList.add('dragging');
                
                // Highlight potential parents (excluding self and current parent)
                state.nodes.forEach(n => {
                    if (n.id !== node.id && n.id !== node.parentId) {
                        n.element.classList.add('highlight');
                    }
                });
                if (e.preventDefault) e.preventDefault();
            }

            function handleNodeTouchStart(e) {
                e.stopPropagation();
                const nodeId = parseInt(this.dataset.id);
                const node = state.nodes.find(n => n.id === nodeId);
                if (!node) return;

                const touch = e.touches[0];
                const currentTime = new Date().getTime();
                if (e.touches.length === 1 && (currentTime - state.lastClickTime) < 300) {
                    editNode(node);
                    state.lastClickTime = 0; 
                    e.preventDefault();
                    return;
                }
                state.lastClickTime = currentTime;

                if (e.touches.length === 1) { // Single touch for dragging or selection
                    selectNode(node);
                    if (state.autoArrange) { e.preventDefault(); return; }

                    state.isDragging = true;
                    state.dragNode = node;
                    state.dragStartPos = { 
                        x: node.x, y: node.y, 
                        clientX: touch.clientX, clientY: touch.clientY 
                    };
                    node.element.classList.add('dragging');
                    state.nodes.forEach(n => {
                        if (n.id !== node.id && n.id !== node.parentId) n.element.classList.add('highlight');
                    });
                    e.preventDefault();
                } else if (e.touches.length === 2) { // Pinch zoom
                    state.isDragging = false; // Stop dragging if it started
                    if (state.dragNode) state.dragNode.element.classList.remove('dragging');
                    
                    state.initialPinchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    state.initialScale = state.scale;
                    e.preventDefault();
                }
            }
            
            function handlePanOrDrag(e) {
                const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);

                if (state.isDragging && state.dragNode && !state.autoArrange) {
                    const dx = (clientX - state.dragStartPos.clientX) / state.scale;
                    const dy = (clientY - state.dragStartPos.clientY) / state.scale;
                    state.dragNode.x = state.dragStartPos.x + dx;
                    state.dragNode.y = state.dragStartPos.y + dy;
                    state.dragNode.element.style.left = `${state.dragNode.x}px`;
                    state.dragNode.element.style.top = `${state.dragNode.y}px`;
                    
                    checkForPotentialParent(state.dragNode, clientX, clientY);
                    updateConnections();
                    if (e.preventDefault && e.touches) e.preventDefault();
                } else if (state.isPanning) {
                    state.offsetX = clientX - state.touchStart.x;
                    state.offsetY = clientY - state.touchStart.y;
                    updateCanvasTransform();
                    if (e.preventDefault && e.touches) e.preventDefault();
                } else if (e.touches && e.touches.length === 2 && state.initialPinchDistance) { // Pinch zoom move
                    const currentDist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const scaleFactor = currentDist / state.initialPinchDistance;
                    const newScale = Math.max(state.minScale, Math.min(state.maxScale, state.initialScale * scaleFactor));
                    
                    const pinchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const pinchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                    state.offsetX = pinchCenterX - (pinchCenterX - state.offsetX) * (newScale / state.scale);
                    state.offsetY = pinchCenterY - (pinchCenterY - state.offsetY) * (newScale / state.scale);
                    state.scale = newScale;
                    
                    updateCanvasTransform();
                    if (e.preventDefault) e.preventDefault();
                }
            }

            function checkForPotentialParent(draggedNode, clientX, clientY) {
                const canvasX = (clientX - state.offsetX) / state.scale;
                const canvasY = (clientY - state.offsetY) / state.scale;
            
                if (state.potentialParent) {
                    state.potentialParent.element.classList.remove('highlight');
                    state.potentialParent = null;
                }
            
                const newPotentialParent = state.nodes.find(node => {
                    if (node.id === draggedNode.id || node.id === draggedNode.parentId) return false;
                    // Check if (canvasX, canvasY) is within node bounds
                    return canvasX >= node.x && canvasX <= node.x + node.width &&
                           canvasY >= node.y && canvasY <= node.y + node.height;
                });
            
                if (newPotentialParent) {
                    // Avoid creating cyclical dependencies
                    if (isAncestor(draggedNode, newPotentialParent)) return;

                    newPotentialParent.element.classList.add('highlight');
                    state.potentialParent = newPotentialParent;
                }
            }

            function isAncestor(potentialChild, potentialParent) {
                let current = potentialParent;
                while (current) {
                    if (current.parentId === potentialChild.id) return true;
                    current = state.nodes.find(n => n.id === current.parentId);
                }
                return false;
            }
            
            function endPanOrDrag(e) {
                if (state.isDragging && state.dragNode) {
                    state.dragNode.element.classList.remove('dragging');
                    state.nodes.forEach(n => n.element.classList.remove('highlight')); // Clear all highlights

                    if (state.potentialParent && !state.autoArrange) {
                        // Remove from old parent's children list
                        if (state.dragNode.parentId) {
                            const oldParent = state.nodes.find(n => n.id === state.dragNode.parentId);
                            if (oldParent) oldParent.children = oldParent.children.filter(child => child.id !== state.dragNode.id);
                        }
                        // Set new parent
                        state.dragNode.parentId = state.potentialParent.id;
                        state.dragNode.originalParentId = state.potentialParent.id;
                        state.potentialParent.children.push(state.dragNode);
                        // Update depth
                        state.dragNode.depth = (state.potentialParent.depth || 0) + 1;
                        // Recreate connection
                        state.connections = state.connections.filter(conn => conn.toId !== state.dragNode.id); // Remove old connection to this node
                        createConnection(state.potentialParent.id, state.dragNode.id);
                        
                        state.potentialParent.element.classList.remove('highlight');
                    }
                    updateConnections(); // Final update
                }
                
                state.isDragging = false;
                state.dragNode = null;
                state.potentialParent = null;
                state.isPanning = false;
                state.initialPinchDistance = null;
                canvas.style.cursor = 'grab';
            }

            // --- Import/Export Functions ---
            function clearCanvas() {
                state.nodes.forEach(node => node.element.remove());
                document.querySelectorAll('.connector').forEach(el => el.remove());
                state.nodes = [];
                state.connections = [];
                state.selectedNode = null;
                state.nextId = 1;
                // Keep scale, offsetX, offsetY unless reset explicitly or by import
            }

            function exportMapData() {
                const nodesToSave = state.nodes.map(node => ({
                    id: node.id,
                    text: node.text,
                    x: node.x,
                    y: node.y,
                    width: node.width,
                    height: node.height,
                    parentId: node.parentId,
                    color: node.color,
                    depth: node.depth
                }));

                const mapData = {
                    nodes: nodesToSave,
                    connections: state.connections,
                    view: {
                        scale: state.scale,
                        offsetX: state.offsetX,
                        offsetY: state.offsetY
                    },
                    settings: {
                        autoArrange: state.autoArrange,
                        horizontalLayout: state.horizontalLayout,
                        nextId: state.nextId
                    }
                };

                const jsonString = JSON.stringify(mapData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'mindmap_export.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function handleFileImport(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const mapData = JSON.parse(e.target.result);
                            loadMapData(mapData);
                        } catch (error) {
                            console.error("Error parsing JSON file:", error);
                            alert("Error al importar el archivo: Formato JSON invÃ¡lido.");
                        }
                    };
                    reader.readAsText(file);
                }
                importFileInput.value = ''; // Reset file input
            }

            function loadMapData(mapData) {
                clearCanvas();

                state.autoArrange = mapData.settings?.autoArrange || false;
                state.horizontalLayout = mapData.settings?.horizontalLayout !== undefined ? mapData.settings.horizontalLayout : window.innerWidth > 768;
                autoArrangeBtn.classList.toggle('active', state.autoArrange);

                let maxId = 0;
                if (mapData.nodes && Array.isArray(mapData.nodes)) {
                    mapData.nodes.forEach(nodeData => {
                        const node = createNode(
                            nodeData.text,
                            nodeData.x,
                            nodeData.y,
                            nodeData.id,
                            nodeData.color,
                            nodeData.width,
                            nodeData.height
                        );
                        // Store parentId temporarily; will link in a second pass
                        node.importedParentId = nodeData.parentId; 
                        node.depth = nodeData.depth || 0; // Restore depth
                        maxId = Math.max(maxId, nodeData.id);
                    });
                }
                
                state.nextId = Math.max(mapData.settings?.nextId || 1, maxId + 1);

                // Second pass: establish parent-child relationships
                state.nodes.forEach(node => {
                    if (node.importedParentId !== null && node.importedParentId !== undefined) {
                        const parentNode = state.nodes.find(p => p.id === node.importedParentId);
                        if (parentNode) {
                            node.parentId = parentNode.id;
                            node.originalParentId = parentNode.id; // For consistency
                            if (!parentNode.children.find(c => c.id === node.id)) { // Avoid duplicates
                                parentNode.children.push(node);
                            }
                        }
                    }
                    delete node.importedParentId; // Clean up
                });
                
                state.connections = mapData.connections || [];
                // If connections weren't explicitly saved, try to rebuild them (optional)
                if (state.connections.length === 0 && mapData.nodes) {
                     mapData.nodes.forEach(nd => {
                        if (nd.parentId !== null && nd.parentId !== undefined) {
                            createConnection(nd.parentId, nd.id);
                        }
                     });
                }


                state.scale = mapData.view?.scale || 1;
                state.offsetX = mapData.view?.offsetX || 0;
                state.offsetY = mapData.view?.offsetY || 0;
                updateCanvasTransform(); // This also calls updateConnections

                if (state.autoArrange) {
                    arrangeNodes();
                } else {
                    updateConnections(); // Ensure connections are drawn based on loaded x,y
                }
                
                if (state.nodes.length > 0) {
                    selectNode(state.nodes.find(n => !n.parentId) || state.nodes[0]); // Select a root or first node
                    centerViewOnSelectedOrRoot();
                } else {
                    resetZoom(); // If map is empty, reset view
                }
            }

        });
    </script>
</body>
</html>
